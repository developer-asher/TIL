# 버블정렬

> 데이터를 두개씩 묶어서 비교한 후 크기가 큰 쪽이 오른쪽으로 가도록 자리를 바꿔가며 크기가 큰 데이터를 오른쪽으로 민다.  
> 그러면 1회전이 끝남과 동시에 이 리스트에서 가장 큰 값이 가장 오른쪽에 가기 때문에 맨 오른쪽 자리가 결정된다.  
> 즉, **n번째 정렬 회차가 끝나면 뒤에서 n번째 자리의 데이터가 확정된다.**

<br />
<img src="https://blog.kakaocdn.net/dn/bUgECt/btqwWZBXDYj/jJwP1TnMQL3u1nbzt5Gzb1/img.gif" width="470px" height="360px" alt="버블정렬"></img>
<br />

## 시간복잡도(Big O)

**- 최악: O(n^2)**: 정렬이 하나도 안되어 있는 경우
**- 최선: O(n)**: 이미 정렬이 되어있는 경우

버블 정렬은 최악의 경우에는 O(N^2)의 시간 복잡도를 갖게 된다. 각 자리를 찾기 위해서 n번의 순회를 해야하며 n번의 순회 동안에 요소의 개수만큼 또 순회를 해야하기 때문이다.

## 장점

in place알고리즘이기 때문에 **메모리가 절약된다.** in place라는 것은 자료를 정렬할 때 추가적인 메모리 공간이 필요한 것이 아니고 데이터가 저장된 그 공간 내에서 정렬을 한다는 뜻.

## 단점

**자료의 개수가 많아질수록 성능이 매우 떨어진다.**

## Stable

버블 정렬은 중복 데이터가 있을 경우 데이터의 위치를 교환하지 않고 지나가기 때문에 stable한 정렬이다.
